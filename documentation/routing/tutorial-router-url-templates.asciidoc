---
title: URL Templates
order: 5
layout: page
---

= URL Templates

URL templates define the mean of including parameters into a route url.
URL template parameters are defined as URL segments within `@Route`, `@RouteAlias` and `@RoutePrefix` annotation values, using `:parameter_name[modifier][(regex)]` syntax, where:

* `parameter_name` is the name of the parameter used to retrive the value of the parameter when a url matching the template is resolved on the server.
* `modifier` is optional and may be one of the following:
** `?` defines an optional parameter which might be missing from the url being resolved,
** `*` defines a wildcard parameter which can be used only as the last segment in the template, resolving all segment values at the end of the url.
* `regex` is also optional and defines the regex used to match the parameter value in the url.
If it's missing, the parameter accepts any value.

Parameter values may be retrieve from a `BeforeEvent` instance on any `Component` in the navigation chain, either parent layout or navigation target.

== Defining URL Templates using `@Route`, `@RouteAlias` and `@RoutePrefix`

The final URL template is the result of the value composition from the `@Route`, `@RouteAlias` and `@RoutePrefix` annotations as explain in <<tutorial-router-layout#,Router Layouts and Nested Router Targets>>.
Any URL segment defined by these annotations may represent a URL parameter.

*Example*: A simple route where the parameter is defined as a middle segment.

[source,java]
----
@Route("user/:userID/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private String userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().get("userID").get();
    }
}
----

[NOTE]
`BeforeEnterEvent` provides `getUrlParameters()` which return a `UrlParameters` instance.
This object contains the parameter values retrieved from the handled URL.

*Example*: Following example demonstrates the use of all annotations to configure two routes on the same view.
In case of routes defined for `ForumThreadView`:

* `"threadID/:threadID"` route will resolve URLs matching `forum/category/:categoryID/threadID/:threadID` and
* `"threadID/:threadID/comment"` route alias resolves into template `forum/category/:categoryID/threadID/:threadID/comment`.

`ForumView` has an empty route for which only the value of its `@RoutePrefix` will be used, so it will resolve URLs matching `forum/category/:categoryID`.

[source,java]
----
@Route(value = "")
@RoutePrefix("forum/category/:categoryID")
public class ForumView extends Div implements RouterLayout,
        BeforeEnterObserver {

    private String categoryID;

    private String threadID;

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        final UrlParameters urlParameters = beforeEnterEvent.getUrlParameters();

        threadID = null;

        categoryID = urlParameters.get("categoryID").get();
        urlParameters.get("threadID").ifPresent(value -> threadID = value);
    }
}

@Route(value = "threadID/:threadID", layout = ForumView.class)
@RouteAlias(value = "threadID/:threadID/comment", layout = ForumView.class)
public class ForumThreadView extends Div implements BeforeEnterObserver {

    private String threadID;

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        threadID = beforeEnterEvent.getUrlParameters().get("threadID").get();

        if ("comment".equals(getLastSegment(beforeEnterEvent))) {
            new CommentDialog().open();
        }
    }
}
----

[NOTE]
As seen in `ForumView`, the defined route contains only one parameter, i.e. `categoryID`.
However, when used as a layout together with `ForumThreadView` target, it's also able to access the parameter defined by `ForumThreadView` routing annotations.

== Optional URL parameter modifier

A URL parameter may be defined as optional, which means that it may or may not be present in the resolved URL.

*Example*: Following route defined as `user/:userID?/edit` accepts both `user/edit` and `user/123/edit` resolved URLs.
In the second case, parameter's value `userID` is `123`, while in the first case the `Optional` provided by `event.getUrlParameters().get("userID")` wraps a `null` value.

[source,java]
----
@Route("user/:userID?/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private String userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().get("userID").
                orElse(CurrentUser.get().getUserID());
    }
}
----

== Wildcard URL parameter modifier

The wildcard parameter may be defined only as the last segment of the route template matching all segments at the end of the URL.
A wildcard parameter is also optional so it'll match also no segments at the end of the URL, in which case, it's value when retrieved from `UrlParameters` is an empty `Optional`.

*Example*: `api/:path*` template may resolve for instance URL path `api/com/vaadin/flow`, where the value of parameter `path` is `"com/vaadin/flow"`.

[source,java]
----
@Route("api/:path*")
public class ApiViewer extends Div implements BeforeEnterObserver {

    private String path;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        path = event.getUrlParameters().get("path").orElse("");
    }
}
----

[NOTE]
Please notice that since the value can be `null` we're using `orElse("")` method of `Optional` to retrieve it.

A more convenient method of accessing the value of a wildcard parameter is `getWildcard` method of `UrlParameters`.
`getWildcard` method returns an empty list if the value of the parameter is missing.

[source,java]
----
@Route("api/:path*")
public class ApiViewer extends Div implements BeforeEnterObserver {

    private List<String> pathSegments;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        pathSegments = event.getUrlParameters().getWildcard("path");
    }
}
----

== URL parameters matching a regex

So far, in all examples discussed, the parameter templates accept any value.
However, in many cases we expect a specific value for a parameter and we want the view to be shown only when that specific value is present in the URL.
This may be achieved by defining a regex for the parameter.

*Example*: Following example limit the value of the `userID` parameter to contain only 9 digits at most making it suitable for an `Integer`:

[source,java]
----
@Route("user/:userID?([0-9]{1,9})/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private Integer userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().getInteger("userID").
                orElse(CurrentUser.get().getUserID());
    }
}
----

[NOTE]
`UrlParameters` provide also methods to access typed parameter values, i.e. `getInteger`, `getLong` and `getBoolean`.
Also `RouteParameterRegex` class define the regex values for these types so the route defined in the above example may be written as `@Route("user/:userID?(" + RouteParameterRegex.INTEGER + ")/edit")`

== Wildcard URL parameter using regex

In case of wildcard parameters the regex is applied to all segments at the end of the URL, individually.
In case one segment fails to match the regex the whole template fails to match the URL.

*Example*: Following route `api/:path*(com|vaadin|flow)` accepts only one of the `com`, `vaadin` or `flow` values as any value of the segments which follow after `api` segment.

* Resolved URLs examples:
** `api/com/vaadin/flow`, where parameter `path` has value `"com/vaadin/flow"`.
** `api/com/flow`, where parameter `path` has value `"com/flow"`
** `api/flow/vaadin`, where parameter `path` has value `"flow/vaadin"`
* Unresolved URL:
** `api/com/vaadin/framework`.

[source,java]
----
@Route("api/:path*(com|vaadin|flow)")
public class ApiViewer extends Div implements BeforeEnterObserver {
}
----

== URL template priority

For an application with a complex structure, the list of route templates may bring some overlapping in the definition of parameters for each route.

The Router engine will deny by default any attempt to register the same route for more than one view.
Also a route containing optional parameters is in conflict with the same route without the parameters and the last to be register will fail.
The failure consists in a `InvalidRouteConfigurationException` being thrown during route registration leading to the termination of the application.

*Example*: Following configuration will fail since both are resolving the same URL `items/show` and this is obvious at configure time.

[source,java]
----
@Route("items/show")
public static class ShowAllView extends Div {
}

// This route will fail when registered and application is terminated.
@Route("items/show/:filter?")
public static class SearchView extends Div {
}
----

[NOTE]
One way to fix this is to make `filter` parameter mandatory, by removing the optional modifier.
The resulted route will look like `@Route("items/show/:filter")`.
The other possibility is to remove `ShowAllView` class and show all items using `SearchView` when the `filter` parameter is missing.

However since the options of combining templates with regex parameters is theoretically infinite, a priority mechanism has to be used when the URL is resolved, instead of failing the application when a conflicting route is registered.
Thus, depending on the parameter modifier and the order the routes are registered, one route has priority over the others.
This is applicable for any defined route, on the same navigation view or another view, and using both `@Route` or `@RouteAlias`.

This is the order is which segments in the registered URL templates are trying to resolve the URL:

1. Static segment.
2. Mandatory parameter.
3. Optional parameter.
4. Next segments following the optional parameter.
5. Wildcard parameter.

*Example*: In the example bellow:

* `items/show` will always resolve into `ShowAllView` navigation target, regardless of the order the routes are registered.
* `items/phone` will be resolved into `ItemView` and `identifier` parameter will have value `"phone"`.
That's because `show` is a static segment within a registered route and has priority over any other sibling segments in other routes.

[source,java]
----
@Route("items/:identifier")
public static class ItemView extends Div {
}

@Route("items/show")
public static class ShowAllView extends Div {
}
----

Same is valid when using `@RouteAlias` on the same navigation target.

*Example*: Folowing URLs are resolved by different routes registered on the same navigation target.

* `thread/last` is resolved by `@RouteAlias("last")`.
* `thread/123` is resolved by `@RouteAlias(":messageID(" + RouteParameterRegex.INTEGER + ")")` and parameter `messageID` will be provided with value `"123"`.
* `thread/web` is resolved by `@RouteAlias(":something?")` and parameter `something` is provided with value `"web"`.

[source,java]
----
@Route(":something?")
@RouteAlias(":messageID(" + RouteParameterRegex.INTEGER + ")")
@RouteAlias("last")
@RoutePrefix("thread")
public static class ThreadView extends Div {

    private Integer messageID;

    private String something;

    private boolean last;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        last = "last".equals(getLastSegment(event));

        messageID = null;
        something = null;

        if (!last) {
            final UrlParameters urlParameters = event.getUrlParameters();

            urlParameters.getInteger("messageID")
                    .ifPresent(value -> messageID = value);
            urlParameters.get("something")
                    .ifPresent(value -> something = value);
        }
    }
}
----

[NOTE]
Even though `@Route(":something?")` is the first one defined, it's the last to process a URL because it's parameter is optional.

[NOTE]
In above example, since all templates resolve into the same navigation target, different parameters are passed to the view.
And even though `messageID` is a mandatory parameter, it might miss from the `UrlParameters` when the URL is resolved by one of the routes not containing `messageID` parameter.

A wildcard template is the last to process the ending segments of a URL, if any other registered URL templates failed.

*Example*: Here we define 3 route templates where the first two contain wildcard parameters.
Here, the templates are:

* `component/:identifier/:path*`
* `component/:identifier/:tab(api)/:path*`
* `component/:identifier/:tab(overview|samples|links|reviews|discussions)`

By definition, any URL matched by the any of last two templates will be matched by the first one as well.
However, due to the priority rules, only URLs not matched by the last two templates will end up being processed by the first one, thus:

* `component/button/api/com/vaadin/flow/button` will be processed by the `component/:identifier/:tab(api)/:path*` with parameters:
** `identifier` = `button`
** `tab` = `api`
** `path` = `com/vaadin/flow/button`
* `component/grid/com/vaadin/flow/grid` will be processed by the `component/:identifier/:path*` with parameters:
** `identifier` = `grid`
** `path` = `com/vaadin/flow/grid`
* `component/label/links` will be processed by the `component/:identifier/:tab(overview|samples|links|reviews|discussions)` with parameters:
** `identifier` = `label`
** `tab` = `links`


[source,java]
----
@Route(value = ":path*" , layout = ParentView.class)
public static class PathView extends Div {
}

@Route(value = ":tab(api)/:path*", layout = ParentView.class)
public static class ApiView extends Div {
}

@Route(value = ":tab(overview|samples|links|reviews|discussions)", layout = ParentView.class)
public static class OthersView extends Div {
}

@RoutePrefix("component/:identifier")
public static class ParentView extends Div implements RouterLayout {
}
----
