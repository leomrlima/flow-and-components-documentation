---
title: URL Templates order: 5 layout: page
---

= URL Templates

URL templates define the mean of including parameters into a route url.
URL template parameters are defined as URL segments within `@Route`, `@RouteAlias` and `@RoutePrefix` annotation values, using `:parameter_name[modifier][(matching_regex)]` syntax, where:

* `parameter_name` is the name of the parameter used to retrive the value of the parameter when a url matching the template is resolved on the server.
* `modifier` is optional and may be one of the following:
** `?` defines an optional parameter which might be missing from the url being resolved,
** `*` defines a wildcard parameter which can be used only as the last segment in the template, resolving all segment values at the end of the url.
* `matching_regex` is also optional and defines the regex used to match the parameter value in the url.
If it's missing, the parameter template accepts any value.

Parameter values may be retrieve from a `BeforeEvent` instance on any `Component` in the navigation chain, either parent layout or navigation target.

== Defining URL Templates using `@Route`, `@RouteAlias` and `@RoutePrefix`

The final URL template is the result of the value composition from the `@Route`, `@RouteAlias` and `@RoutePrefix` annotations as explain in <<tutorial-router-layout#,Router Layouts and Nested Router Targets>>.
Any URL segment defined by these annotations may represent a URL parameter.

*Example*: A simple route where the parameter is defined as a middle segment.

[source,java]
----
@Route("user/:userID/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private String userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().get("userID").get();
    }
}
----

[NOTE]
`BeforeEnterEvent` provides `getUrlParameters()` which return a `UrlParameters` instance.
This object contains the parameter values retrieved from the handled URL.

*Example*: Following example demonstrates the use of all annotations to configure two routes on the same view.
In case of routes defined for `ForumThreadView`:

* `"threadID/:threadID"` route will resolve URLs matching `forum/category/:categoryID/threadID/:threadID` and
* `"threadID/:threadID/comment"` route alias resolves into template `forum/category/:categoryID/threadID/:threadID/comment`.

`ForumView` has an empty route for which only the value of its `@RoutePrefix` will be used, so it will resolve URLs matching `forum/category/:categoryID`.

[source,java]
----
@Route(value = "")
@RoutePrefix("forum/category/:categoryID")
public class ForumView extends Div implements RouterLayout,
        BeforeEnterObserver {

    private String categoryID;

    private String threadID;

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        final UrlParameters urlParameters = beforeEnterEvent.getUrlParameters();

        threadID = null;

        categoryID = urlParameters.get("categoryID").get();
        urlParameters.get("threadID").ifPresent(value -> threadID = value);
    }
}

@Route(value = "threadID/:threadID", layout = ForumView.class)
@RouteAlias(value = "threadID/:threadID/comment", layout = ForumView.class)
public class ForumThreadView extends Div implements BeforeEnterObserver {

    private String threadID;

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        threadID = beforeEnterEvent.getUrlParameters().get("threadID").get();

        if ("comment".equals(getLastSegment(beforeEnterEvent))) {
            new CommentDialog().open();
        }
    }
}
----

[NOTE]
As seen in `ForumView`, the defined route contains only one parameter, i.e. `categoryID`.
However, when used as a layout together with `ForumThreadView` target, it's also able to access the parameter defined by `ForumThreadView` routing annotations.

== Optional URL parameter modifier

A URL parameter may be defined as optional, which means that it may or may not be present in the resolved URL.

*Example*: Following route defined as `user/:userID?/edit` accepts both `user/edit` and `user/123/edit` resolved URLs.
In the second case, parameter's value `userID` is `123`, while in the first case the `Optional` provided by `event.getUrlParameters().get("userID")` wraps a `null` value.

[source,java]
----
@Route("user/:userID?/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private String userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().get("userID").
                orElse(CurrentUser.get().getUserID());
    }
}
----

== Wildcard URL parameter modifier

The wildcard parameter may be defined only as the last segment of the route template matching all segments at the end of the URL.
A wildcard parameter is also optional so it'll match also no segments at the end of the URL, in which case, it's value when retrieved from `UrlParameters` is an empty `Optional`.

*Example*: `api/:path*` template may resolve for instance URL path `api/com/vaadin/flow`, where the value of parameter `path` is `com/vaadin/flow`.

[source,java]
----
@Route("api/:path*")
public class ApiViewer extends Div implements BeforeEnterObserver {

    private String path;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        path = event.getUrlParameters().get("path").orElse("");
    }
}
----

[NOTE]
Please notice that since the value can be `null` we're using `orElse("")` method of `Optional` to retrieve it.

A more convenient method of accessing the value of a wildcard parameter is `getWildcard` method of `UrlParameters`.
`getWildcard` method returns an empty list if the value of the parameter is missing.

[source,java]
----
@Route("api/:path*")
public class ApiViewer extends Div implements BeforeEnterObserver {

    private List<String> pathSegments;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        pathSegments = event.getUrlParameters().getWildcard("path");
    }
}
----

== URL parameters matching a regex

So far, in all examples discussed, the parameter templates accept any value.
However, in many cases we expect a specific value for a parameter and we want the view to be shown only when that specific value is present in the URL.
This may be achieved by defining a regex for the parameter.

*Example*: Following example limit the value of the `userID` parameter to contain only 9 digits at most making it suitable for an `Integer`:

[source,java]
----
@Route("user/:userID?([0-9]{1,9})/edit")
public class UserProfileEdit extends Div implements BeforeEnterObserver {

    private Integer userID;

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        userID = event.getUrlParameters().getInteger("userID").
                orElse(CurrentUser.get().getUserID());
    }
}
----

[NOTE]
`UrlParameters` provide also methods to access typed parameter values, i.e. `getInteger`, `getLong` and `getBoolean`.
Also `RouteParameterRegex` class define the regex values for these types so the route defined in the above example may be written as `@Route("user/:userID?(" + RouteParameterRegex.INTEGER + ")/edit")`

== Wildcard URL parameter using regex

In case of wildcard parameters the regex is applied to all segments at the end of the URL, individually.
In case one segment fails to match the regex the whole template fails to match the URL.

*Example*: Following route `api/:path*(com|vaadin|flow)` accepts only one of the `com`, `vaadin` or `flow` values as any value of the segments which follow after `api` segment.

* Resolved URLs examples:
** `api/com/vaadin/flow`
** `api/com/flow`
** `api/flow/vaadin`.
* Unresolved URL:
** `api/com/vaadin/framework`.

[source,java]
----
    @Route("api/:path*(com|vaadin|flow)")
    public class ApiViewer extends Div implements BeforeEnterObserver {

    }
----

== URL template priority

For an application with a complex structure, the list of route templates may bring some overlapping in the definition of parameters for each route.

The Router engine will deny by default any attempt to register the same route for more than one view.
Also a route containing optional parameters is in conflict with the same route without the parameters and the last to be register will fail.

However since the options of combining templates with regex parameters is theoretically infinite, a priority mechanism has to be used when the URL is resolved, instead of failing the application when a conflicting route is registered.
Thus, depending on the parameter modifier and the order the routes are registered, one route has priority over the others.
This is applicable for any defined route, on the same navigation view or another view, and using both `@Route` or `@RouteAlias`.

